(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{473:function(t,s,a){"use strict";a.r(s);var n=a(16),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"作用域和作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域和作用域链"}},[t._v("#")]),t._v(" 作用域和作用域链")]),t._v(" "),a("p",[t._v("创建函数的时候，已经声明了当前函数的作用域==>当前创建函数所处的上下文。如果是在全局下创建的函数就是[[scope]]:EC(G)，函数执行的时候，形成一个全新的私有上下文EC(FN)，供字符串代码执行(进栈执行)")]),t._v(" "),a("ul",[a("li",[t._v("定义\n简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成")])]),t._v(" "),a("ol",[a("li",[t._v("全局作用域：")])]),t._v(" "),a("ul",[a("li",[t._v("最外层函数和最外层函数外面定义的变量拥有全局作用域")]),t._v(" "),a("li",[t._v("所有未定义直接赋值的变量自动声明为全局作用域")]),t._v(" "),a("li",[t._v("所有window对象的属性拥有全局作用域")]),t._v(" "),a("li",[t._v("全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("函数作用域：")])]),t._v(" "),a("ul",[a("li",[t._v("函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到")]),t._v(" "),a("li",[t._v("作用域是分层的，内层作用域可以访问外层作用域，反之不行")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("块级作用域")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）")])]),t._v(" "),a("li",[a("p",[t._v("let和const声明的变量不会有变量提升，也不可以重复声明")])]),t._v(" "),a("li",[a("p",[t._v("在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。")])]),t._v(" "),a("li",[a("p",[t._v("作用\n作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。")])]),t._v(" "),a("li",[a("p",[t._v("作用域链")]),t._v(" "),a("ul",[a("li",[t._v("在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。")]),t._v(" "),a("li",[t._v("作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。")]),t._v(" "),a("li",[t._v("作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。")])])])]),t._v(" "),a("h2",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),a("p",[t._v("函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否.")]),t._v(" "),a("p",[t._v("在js中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。")]),t._v(" "),a("ul",[a("li",[t._v("我们把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包。")])]),t._v(" "),a("blockquote",[a("p",[t._v("闭包是指有权访问另一个函数作用域中的变量的函数--《JavaScript高级程序设计》")])]),t._v(" "),a("h3",{attrs:{id:"特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。")]),t._v(" "),a("ul",[a("li",[t._v("1.1.闭包是密闭的容器，，类似于set、map容器，存储数据的")]),t._v(" "),a("li",[t._v("1.2.闭包是一个对象，存放数据的格式为 key-value 形式")])])]),t._v(" "),a("li",[a("p",[t._v("函数嵌套函数")])]),t._v(" "),a("li",[a("p",[t._v("本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除")])])]),t._v(" "),a("h3",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）")])]),t._v(" "),a("li",[a("p",[t._v("保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；")])])]),t._v(" "),a("h3",{attrs:{id:"应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),a("p",[t._v("闭包的两个场景，闭包的两大作用：保存/保护。 在开发中, 其实我们随处可见闭包的身影, 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。")]),t._v(" "),a("h3",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),a("p",[t._v("延长局部变量的生命周期")]),t._v(" "),a("h3",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),a("p",[t._v("会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏")]),t._v(" "),a("h2",{attrs:{id:"执行上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),a("h3",{attrs:{id:"执行上下文类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文类型"}},[t._v("#")]),t._v(" 执行上下文类型")]),t._v(" "),a("ol",[a("li",[t._v("全局执行上下文")])]),t._v(" "),a("p",[t._v("任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("函数执行上下文")])]),t._v(" "),a("p",[t._v("当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("eval函数执行上下文")])]),t._v(" "),a("p",[t._v("执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。")]),t._v(" "),a("h3",{attrs:{id:"执行上下文栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈"}},[t._v("#")]),t._v(" 执行上下文栈")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("JavaScript引擎使用执行上下文栈来管理执行上下文")])]),t._v(" "),a("li",[a("p",[t._v("当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文")])])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Hello World!'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("first")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Inside first function'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("second")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Again inside first function'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("second")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Inside second function'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("first")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//执行顺序")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//先执行second(),在执行first()")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br")])]),a("h3",{attrs:{id:"创建执行上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建执行上下文"}},[t._v("#")]),t._v(" 创建执行上下文")]),t._v(" "),a("ul",[a("li",[t._v("创建执行上下文有两个阶段：创建阶段和执行阶段")])]),t._v(" "),a("ol",[a("li",[t._v("创建阶段")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("this绑定")]),t._v(" "),a("ul",[a("li",[t._v("在全局执行上下文中，this指向全局对象（window对象）")]),t._v(" "),a("li",[t._v("在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined")])])]),t._v(" "),a("li",[a("p",[t._v("创建词法环境组件")]),t._v(" "),a("ul",[a("li",[t._v("词法环境是一种有标识符——变量映射的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。")]),t._v(" "),a("li",[t._v("词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域")])])]),t._v(" "),a("li",[a("p",[t._v("创建变量环境组件")])])]),t._v(" "),a("p",[t._v("变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("执行阶段")])]),t._v(" "),a("p",[t._v("此阶段会完成对变量的分配，最后执行完代码")]),t._v(" "),a("p",[t._v("简单来说执行上下文就是指：")]),t._v(" "),a("p",[t._v("在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。\n在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("全局上下文：变量定义，函数声明")])]),t._v(" "),a("li",[a("p",[t._v("函数上下文：变量定义，函数声明，this，arguments")])])]),t._v(" "),a("h2",{attrs:{id:"this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),a("h3",{attrs:{id:"this-的绑定分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this-的绑定分类"}},[t._v("#")]),t._v(" this 的绑定分类")]),t._v(" "),a("ol",[a("li",[t._v("默认绑定")])]),t._v(" "),a("p",[t._v("默认绑定通常是指函数独立调用，不涉及其他绑定规则。非严格模式下，this指向window，严格模式下，this指向undefined。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("隐式绑定")])]),t._v(" "),a("p",[t._v("函数的调用是在某个对象上触发的，即调用位置存在上下文对象，通俗点说就是**XXX.func()**这种调用模式。\n此时func的this指向XXX，但如果存在链式调用，例如XXX.YYY.ZZZ.func，记住一个原则：this永远指向最后调用它的那个对象。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("p",[t._v("显示绑定（apply/call/bind/new）")])]),t._v(" "),a("li",[a("p",[t._v("箭头函数")])])]),t._v(" "),a("p",[t._v("箭头函数没有自己的this，它的this指向外层作用域的this，且指向函数定义时的this而非执行时。")]),t._v(" "),a("p",[t._v("this指向外层作用域的this: 箭头函数没有this绑定，但它可以通过作用域链查到外层作用域的this\n指向函数定义时的this而非执行时: JavaScript是静态作用域，就是函数定义之后，作用域就定死了，跟它执行时的地方无关。更详细的介绍见JavaScript之静态作用域与动态作用域。")]),t._v(" "),a("h3",{attrs:{id:"对this对象的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对this对象的理解"}},[t._v("#")]),t._v(" 对this对象的理解")]),t._v(" "),a("p",[t._v("this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。")])]),t._v(" "),a("li",[a("p",[t._v("第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。")])]),t._v(" "),a("li",[a("p",[t._v("第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。")])]),t._v(" "),a("li",[a("p",[t._v("第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。")])])]),t._v(" "),a("p",[t._v("这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.cn/post/7019470820057546766",target:"_blank",rel:"noopener noreferrer"}},[t._v("《2w字大章 38道面试题》彻底理清JS中this指向问题"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"call-apply-bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind"}},[t._v("#")]),t._v(" call/apply/bind")]),t._v(" "),a("ul",[a("li",[t._v("apply")])]),t._v(" "),a("p",[t._v("接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。")]),t._v(" "),a("ul",[a("li",[t._v("call")])]),t._v(" "),a("p",[t._v("传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("bind")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("都能改变 this 的指向")])]),t._v(" "),a("li",[a("p",[t._v("call()/apply()是"),a("strong",[t._v("立即调用函数")])])]),t._v(" "),a("li",[a("p",[t._v("bind()是将函数返回，因此后面还需要加"),a("code",[t._v("()")]),t._v("才能调用。")])]),t._v(" "),a("li",[a("p",[t._v("bind()传参的方式与 call()相同。")])])])])]),t._v(" "),a("h2",{attrs:{id:"箭头函数和普通函数的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数和普通函数的区别"}},[t._v("#")]),t._v(" 箭头函数和普通函数的区别")]),t._v(" "),a("ol",[a("li",[t._v("箭头函数比普通函数更加简洁")])]),t._v(" "),a("ul",[a("li",[t._v("如果没有参数，就直接写一个空括号即可")]),t._v(" "),a("li",[t._v("如果只有一个参数，可以省去参数的括号")]),t._v(" "),a("li",[t._v("如果有多个参数，用逗号分割")]),t._v(" "),a("li",[t._v("如果函数体的返回值只有一句，可以省略大括号")]),t._v(" "),a("li",[t._v("如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("doesNotReturn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("箭头函数没有自己的this")])]),t._v(" "),a("p",[t._v("头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("箭头函数继承来的this指向永远不会改变")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'GLOBAL'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("id")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'OBJ'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("a")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("b")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nobj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 'OBJ'")]),t._v("\nobj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 'GLOBAL'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Uncaught TypeError: obj.b is not a constructor")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br")])]),a("p",[t._v("对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("call()、apply()、bind()等方法不能改变箭头函数中this的指向")]),t._v(" "),a("li",[t._v("箭头函数不能作为构造函数使用")]),t._v(" "),a("li",[t._v("箭头函数没有自己的arguments")]),t._v(" "),a("li",[t._v("箭头函数没有prototype")]),t._v(" "),a("li",[t._v("箭头函数不能用作Generator函数，不能使用yeild关键字")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/e2zUVXodtIACGmsUb8gbbg",target:"_blank",rel:"noopener noreferrer"}},[t._v("一篇讲透：箭头函数、普通函数有什么区别"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"eventloop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[t._v("#")]),t._v(" EventLoop")]),t._v(" "),a("h3",{attrs:{id:"什么是eventloop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是eventloop"}},[t._v("#")]),t._v(" 什么是EventLoop")]),t._v(" "),a("ol",[a("li",[t._v("JavaScript将任务分为同步任务和异步任务，同步任务进入主线中中，异步任务首先到Event Table进行回调函数注册。")]),t._v(" "),a("li",[t._v("当异步任务的触发条件满足，将回调函数从Event Table压入Event Queue中。")]),t._v(" "),a("li",[t._v("主线程里面的同步任务执行完毕，系统会去Event Queue中读取异步的回调函数。")]),t._v(" "),a("li",[t._v("只要主线程空了，就会去Event Queue读取回调函数，这个过程被称为Event Loop。")])]),t._v(" "),a("h3",{attrs:{id:"event-loop执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop执行过程"}},[t._v("#")]),t._v(" Event Loop执行过程")]),t._v(" "),a("ol",[a("li",[t._v("代码开始执行，创建一个全局调用栈，script作为宏任务执行")]),t._v(" "),a("li",[t._v("执行过程过同步任务立即执行，异步任务根据异步任务类型分别注册到微任务队列和宏任务队列")]),t._v(" "),a("li",[t._v("同步任务执行完毕，查看微任务队列\n"),a("ul",[a("li",[t._v("若存在微任务，将微任务队列全部执行(包括执行微任务过程中产生的新微任务)")]),t._v(" "),a("li",[t._v("若无微任务，查看宏任务队列，执行第一个宏任务，宏任务执行完毕，查看微任务队列，重复上述操作，直至宏任务队列为空")])])])]),t._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"https://juejin.cn/post/7020328988715270157#heading-11",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript之彻底理解EventLoop"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6868849475008331783",target:"_blank",rel:"noopener noreferrer"}},[t._v("【前端体系】从一道面试题谈谈对EventLoop的理解"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844903764202094606#heading-30",target:"_blank",rel:"noopener noreferrer"}},[t._v("一次弄懂Event Loop（彻底解决此类面试问题）"),a("OutboundLink")],1)])])]),t._v(" "),a("h2",{attrs:{id:"v8垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8垃圾回收机制"}},[t._v("#")]),t._v(" V8垃圾回收机制")]),t._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6995706341041897486#heading-0",target:"_blank",rel:"noopener noreferrer"}},[t._v("赠你13张图，助你20分钟打败了「V8垃圾回收机制」"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6909239354418266119",target:"_blank",rel:"noopener noreferrer"}},[t._v("V8 引擎垃圾回收与内存分配"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6981588276356317214",target:"_blank",rel:"noopener noreferrer"}},[t._v("「硬核JS」你真的了解垃圾回收机制吗"),a("OutboundLink")],1)])])])])}),[],!1,null,null,null);s.default=e.exports}}]);