(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{571:function(e,t,r){"use strict";r.r(t);var a=r(16),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"reconciler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reconciler"}},[e._v("#")]),e._v(" Reconciler")]),e._v(" "),r("h3",{attrs:{id:"stack-reconciler-react15"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#stack-reconciler-react15"}},[e._v("#")]),e._v(" Stack Reconciler（React15）")]),e._v(" "),r("ul",[r("li",[e._v("Stack Reconciler 是一个同步的递归过程")])]),e._v(" "),r("ol",[r("li",[r("p",[e._v("栈调和机制下的diff算法，其实是树的深度优先遍历的过程")])]),e._v(" "),r("li",[r("p",[e._v("递归的过程是同步的，不可以被打断，意味着javaScript线程长时间占用主线程")])]),e._v(" "),r("li",[r("p",[e._v("导致渲染卡顿/卡死、交互长时间无响应")])])]),e._v(" "),r("h3",{attrs:{id:"fiber-reconciler-react16"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber-reconciler-react16"}},[e._v("#")]),e._v(" Fiber Reconciler（React16）")]),e._v(" "),r("p",[e._v("Fiber Reconciler 是一种基于浏览器的"),r("strong",[e._v("单线程调度算法")]),e._v(".")]),e._v(" "),r("h2",{attrs:{id:"fiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[e._v("#")]),e._v(" Fiber")]),e._v(" "),r("h3",{attrs:{id:"你是如何理解-fiber-的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#你是如何理解-fiber-的"}},[e._v("#")]),e._v(" 你是如何理解 fiber 的?")]),e._v(" "),r("p",[e._v("React 16 之前 ，"),r("code",[e._v("reconcilation")]),e._v("  算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归.")]),e._v(" "),r("p",[r("code",[e._v("Fiber")]),e._v("："),r("strong",[e._v("一种将 "),r("code",[e._v("recocilation")]),e._v(" （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。")])]),e._v(" "),r("ul",[r("li",[r("p",[e._v("React Fiber 又称为纤程可以理解为：")]),e._v(" "),r("p",[e._v("React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。")])]),e._v(" "),r("li",[r("p",[e._v("Fiber包含三层含义：")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。")])]),e._v(" "),r("li",[r("p",[e._v("作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。")])]),e._v(" "),r("li",[r("p",[e._v("作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）")])])])])]),e._v(" "),r("h2",{attrs:{id:"执行顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行顺序"}},[e._v("#")]),e._v(" 执行顺序")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("实现虚拟Dom")])]),e._v(" "),r("li",[r("p",[e._v("开始workOnRoot")])])]),e._v(" "),r("ol",[r("li",[r("p",[e._v("beginWork构建")])]),e._v(" "),r("li",[r("p",[e._v("completeWork完成")])])]),e._v(" "),r("ul",[r("li",[e._v("遍历fiber")])]),e._v(" "),r("ol",[r("li",[e._v("开始遍历fiber节点之后")]),e._v(" "),r("li",[e._v("如果有儿子，开始处理儿子")]),e._v(" "),r("li",[e._v("如果没有儿子，自己结束了，开始处理弟弟")]),e._v(" "),r("li",[e._v("如果没有弟弟，父亲就结束了，说明自己是最小到儿子了，开始处理叔叔")]),e._v(" "),r("li",[e._v("如果没有叔叔，找它爷爷")])]),e._v(" "),r("h2",{attrs:{id:"问答环节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问答环节"}},[e._v("#")]),e._v(" 问答环节")]),e._v(" "),r("h3",{attrs:{id:"react的fiber为什么要用链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react的fiber为什么要用链表"}},[e._v("#")]),e._v(" react的fiber为什么要用链表?")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJTGANs5yAAD4e6ACv8Q643.png",alt:""}})]),e._v(" "),r("p",[e._v("根据图中高亮部分的提示不难看出，首次渲染和更新渲染的区别，在于调用的是 mountState，还是 updateState。mountState 做了什么，你已经非常清楚了；而 updateState 之后的操作链路，虽然涉及的代码有很多，但其实做的事情很容易理解：按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染。")]),e._v(" "),r("p",[e._v("我们把 mountState 和 updateState 做的事情放在一起来看：mountState（首次渲染）构建链表并渲染；updateState 依次遍历链表并渲染。")]),e._v(" "),r("p",[e._v("看到这里，你是不是已经大概知道怎么回事儿了？没错，hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的。")]),e._v(" "),r("p",[e._v("这个现象有点像我们构建了一个长度确定的数组，数组中的每个坑位都对应着一块确切的信息，后续每次从数组里取值的时候，只能够通过索引（也就是位置）来定位数据。也正因为如此，在许多文章里，都会直截了当地下这样的定义：Hooks 的本质就是数组。但读完这一课时的内容你就会知道，Hooks 的本质其实是链表")]),e._v(" "),r("h2",{attrs:{id:"推荐阅读"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#推荐阅读"}},[e._v("#")]),e._v(" 推荐阅读")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/4F_1G3zfmO8mxUgVw1HlyQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("面试官问：React 为什么要使用 Fiber 架构 ？"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=i.exports}}]);