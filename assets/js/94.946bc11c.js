(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{509:function(t,_,v){"use strict";v.r(_);var r=v(16),a=Object(r.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"简述版"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简述版"}},[t._v("#")]),t._v(" 简述版")]),t._v(" "),v("ol",[v("li",[t._v("解析URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。")]),t._v(" "),v("li",[t._v("缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。")]),t._v(" "),v("li",[t._v("DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。")]),t._v(" "),v("li",[t._v("获取MAC地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。")]),t._v(" "),v("li",[t._v("TCP三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。")]),t._v(" "),v("li",[t._v("HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。")]),t._v(" "),v("li",[t._v("返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。")]),t._v(" "),v("li",[t._v("页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。")]),t._v(" "),v("li",[t._v("TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。")])]),t._v(" "),v("h2",{attrs:{id:"详细-拆解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#详细-拆解"}},[t._v("#")]),t._v(" 详细-拆解")]),t._v(" "),v("h2",{attrs:{id:"_1-查找缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-查找缓存"}},[t._v("#")]),t._v(" 1.查找缓存")]),t._v(" "),v("ul",[v("li",[t._v("http 强缓存 exprise")]),t._v(" "),v("li",[t._v("浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；")]),t._v(" "),v("li",[t._v("操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；")]),t._v(" "),v("li",[t._v("路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；")]),t._v(" "),v("li",[t._v("ISP缓存：若上述均失败，继续向ISP搜索。")])]),t._v(" "),v("h3",{attrs:{id:"_2-dns-解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-dns-解析"}},[t._v("#")]),t._v(" 2. DNS 解析")]),t._v(" "),v("ul",[v("li",[t._v("DNS 域名查询")])]),t._v(" "),v("ol",[v("li",[t._v("DNS 走缓存")]),t._v(" "),v("li",[t._v("开启 Dns 预解析 x-dns-prefetch-control")]),t._v(" "),v("li",[t._v("dns-prefetch 强制对 域名做预解析")]),t._v(" "),v("li",[t._v("端内：提前初始化 WebView 并且加载域名开始解析，端外：iframe")])]),t._v(" "),v("ul",[v("li",[t._v("根据域名得到 ip 地址")])]),t._v(" "),v("h3",{attrs:{id:"_3-建立-tcp-链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-建立-tcp-链接"}},[t._v("#")]),t._v(" 3. 建立 TCP 链接")]),t._v(" "),v("ul",[v("li",[t._v("TCP 三次握手")])]),t._v(" "),v("h3",{attrs:{id:"浏览器发起-http-请求-总共-2s"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器发起-http-请求-总共-2s"}},[t._v("#")]),t._v(" 浏览器发起 HTTP 请求（ 总共 2s）")]),t._v(" "),v("ul",[v("li",[t._v("协商缓存")]),t._v(" "),v("li",[t._v("请求阻塞（同域名 并发 6 个）域名散列")])]),t._v(" "),v("h3",{attrs:{id:"服务器响应-http-请求-返回-html-内容"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务器响应-http-请求-返回-html-内容"}},[t._v("#")]),t._v(" 服务器响应 HTTP 请求，返回 HTML 内容")]),t._v(" "),v("ul",[v("li",[t._v("Service Worker")]),t._v(" "),v("li",[t._v("CDN")]),t._v(" "),v("li",[t._v("避免重定向")])]),t._v(" "),v("h3",{attrs:{id:"浏览器解析-html-代码-并请求-html-代码中的资源"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器解析-html-代码-并请求-html-代码中的资源"}},[t._v("#")]),t._v(" 浏览器解析 HTML 代码，并请求 HTML 代码中的资源")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("构建CSS规则树：生成CSS规则树（CSS Rule Tree）")])]),t._v(" "),v("li",[v("p",[t._v("构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象")]),t._v(" "),v("ul",[v("li",[t._v("遇到 script 标签 用 defer 和 async，避免阻塞")])])]),t._v(" "),v("li",[v("p",[t._v("构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）")])]),t._v(" "),v("li",[v("p",[t._v("布局（Layout）：计算出每个节点在屏幕中的位置")]),t._v(" "),v("ul",[v("li",[t._v("重绘")]),t._v(" "),v("li",[t._v("回流")])])]),t._v(" "),v("li",[v("p",[t._v("绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。")])])]),t._v(" "),v("h4",{attrs:{id:"解析js"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解析js"}},[t._v("#")]),t._v(" 解析JS")]),t._v(" "),v("ul",[v("li",[t._v("创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。")]),t._v(" "),v("li",[t._v("加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译")]),t._v(" "),v("li",[t._v("预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。")]),t._v(" "),v("li",[t._v("解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。")])]),t._v(" "),v("h3",{attrs:{id:"断开链接-tcp四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#断开链接-tcp四次挥手"}},[t._v("#")]),t._v(" 断开链接 TCP四次挥手")]),t._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://mp.weixin.qq.com/s/0lz4vX3R7DcxuSdLJKEc8Q",target:"_blank",rel:"noopener noreferrer"}},[t._v("阿里二面问了我30分钟从URL输入到渲染"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=a.exports}}]);