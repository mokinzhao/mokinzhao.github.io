(window.webpackJsonp=window.webpackJsonp||[]).push([[250],{672:function(r,t,a){"use strict";a.r(t);var e=a(16),s=Object(e.a)({},(function(){var r=this,t=r.$createElement,a=r._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h2",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[r._v("#")]),r._v(" 简介")]),r._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://esbuild.github.io/",target:"_blank",rel:"noopener noreferrer"}},[r._v("官网"),a("OutboundLink")],1)])]),r._v(" "),a("p",[r._v("Esbuild 是由 Figma 的 CTO 「Evan Wallace」基于 Golang 开发的一款打包工具，相比传统的打包工具，主打性能优势，在构建速度上可以快 10~100 倍。")]),r._v(" "),a("ul",[a("li",[r._v("为什么这么快 ？")])]),r._v(" "),a("ol",[a("li",[r._v("js是单线程串行，esbuild是新开一个进程，然后多线程并行，充分发挥多核优势")]),r._v(" "),a("li",[r._v("go是纯机器码，肯定要比JIT快")]),r._v(" "),a("li",[r._v("不使用 AST，优化了构建流程。（也带来了一些缺点，后面会说）")])]),r._v(" "),a("h2",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[r._v("#")]),r._v(" 优点")]),r._v(" "),a("h3",{attrs:{id:"golang-开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#golang-开发"}},[r._v("#")]),r._v(" Golang 开发")]),r._v(" "),a("p",[r._v("采用 Go 语言开发，相比于 单线程 + JIT 性质的解释型语言 ，使用 Go 的优势在于 :")]),r._v(" "),a("ol",[a("li",[a("p",[r._v("一方面可以充分利用多线程打包，并且线程之间共享内容，而 JS 如果使用多线程还需要有线程通信(postMessage)的开销；")])]),r._v(" "),a("li",[a("p",[r._v("另一方面直接编译成机器码，而不用像 Node 一样先将 JS 代码解析为字节码，然后转换为机器码，大大节省了程序运行时间。")])])]),r._v(" "),a("h3",{attrs:{id:"多核并行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多核并行"}},[r._v("#")]),r._v(" 多核并行")]),r._v(" "),a("p",[r._v("内部打包算法充分利用多核 CPU 优势。Esbuild 内部算法设计是经过精心设计的，尽可能充分利用所有的 CPU 内核。所有的步骤尽可能并行，这也是得益于 Go 当中多线程共享内存的优势，而在 JS 中所有的步骤只能是串行的。 Data to Drag")]),r._v(" "),a("h3",{attrs:{id:"从零造轮子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从零造轮子"}},[r._v("#")]),r._v(" 从零造轮子")]),r._v(" "),a("p",[r._v("从零开始造轮子，没有任何第三方库的黑盒逻辑，保证极致的代码性能。")]),r._v(" "),a("h3",{attrs:{id:"高效利用内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高效利用内存"}},[r._v("#")]),r._v(" 高效利用内存")]),r._v(" "),a("p",[r._v("一般而言，在 JS 开发的传统打包工具当中一般会频繁地解析和传递 AST 数据，比如 string -> TS -> JS -> string，这其中会涉及复杂的编译工具链，比如 webpack -> babel -> terser，每次接触到新的工具链，都得重新解析 AST，导致大量的内存占用。而 Esbuild 中从头到尾尽可能地复用一份 AST 节点数据，从而大大提高了内存的利用效率，提升编译性能。")]),r._v(" "),a("h2",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[r._v("#")]),r._v(" 缺点")]),r._v(" "),a("p",[r._v("esbuild 同样不是完美的（如果真有那么完美为什么还没有大面积使用呢？），为了保证 esbuild 的编译效率，esbuild 没有提供 AST 的操作能力。所以一些通过 AST 处理代码的 babel-plugin 没有很好的方法过渡到 esbuild 中（说的就是你 babel-plugin-import）。so，如果你的项目使用了 babel-plugin-import, 或者一些自定义的 babel-plugin 。在目前来看是没有很好的迁移方案的。")]),r._v(" "),a("h2",{attrs:{id:"与swc对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与swc对比"}},[r._v("#")]),r._v(" 与SWC对比")]),r._v(" "),a("h3",{attrs:{id:"速度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#速度"}},[r._v("#")]),r._v(" 速度")]),r._v(" "),a("p",[r._v("Esbuild 与 SWC 在性能上是在一个量级的，这里通过仓库的例子 Esbuild 略快，但不排除其他例子里面 SWC 比 Esbuild 略快的场景")]),r._v(" "),a("h3",{attrs:{id:"兼容性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#兼容性"}},[r._v("#")]),r._v(" 兼容性")]),r._v(" "),a("ul",[a("li",[r._v("Esbuild 本身的限制，包括如下：\n"),a("ul",[a("li",[r._v("没有 TS 类型检查")]),r._v(" "),a("li",[r._v("不能操作 AST")]),r._v(" "),a("li",[r._v("不支持装饰器语法")]),r._v(" "),a("li",[r._v("产物 target 无法降级到 ES5 及以下")])])])]),r._v(" "),a("p",[r._v("意味着需要 ES5 产物的场景只用 Esbuild 无法胜任。")]),r._v(" "),a("ul",[a("li",[r._v("相比之下，SWC 的兼容性更好：\n"),a("ul",[a("li",[r._v("产物支持 ES5 格式")]),r._v(" "),a("li",[r._v("支持装饰器语法")]),r._v(" "),a("li",[r._v("可以通过写 JS 插件操作 AST")])])])]),r._v(" "),a("h3",{attrs:{id:"应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[r._v("#")]),r._v(" 应用场景")]),r._v(" "),a("p",[r._v("对于 Esbuild 和 SWC，很多时候我们都在对比两者的性能而忽略了应用场景。对于前端的构建工具来说主要有这样几个垂直的功能:")]),r._v(" "),a("ul",[a("li",[r._v("Bundler")]),r._v(" "),a("li",[r._v("Transformer")]),r._v(" "),a("li",[r._v("Minimizer")])]),r._v(" "),a("p",[r._v("从上面的速度和兼容性对比可以看出，Esbuild 和 SWC 作为 transformer 性能是差不多的，但 Esbuild 兼容性远远不及 SWC。因此，SWC 作为 Transformer 更胜一筹。\n但作为 Bundler 以及 Minimizer，SWC 就显得捉襟见肘了，首先官方的 swcpack 目前基本处于不可用状态，Minimizer 方面也非常不成熟，很容易碰到兼容性问题。\n而 Esbuild 作为 Bundler 已经被 Vite 作为开发阶段的依赖预打包工具，同时也被大量用作线上 esm CDN 服务，比如esm.sh等等；作为 Minimizer ，Esbuild 也已足够成熟，目前已经被 Vite 作为 JS 和 CSS 代码的压缩工具用上了生产环境。")]),r._v(" "),a("p",[r._v("综合来看，SWC 与 Esbuild 的关系类似于当下的 Babel 和 Webpack，前者更适合做兼容性和自定义要求高的 Transformer(比如移动端业务场景)，而后者适合做 Bundler 和 Minimizer，以及兼容性和自定义要求均不高的 Transformer。")]),r._v(" "),a("h2",{attrs:{id:"推荐阅读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#推荐阅读"}},[r._v("#")]),r._v(" 推荐阅读")]),r._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6918927987056312327",target:"_blank",rel:"noopener noreferrer"}},[r._v("ESbuild 介绍"),a("OutboundLink")],1)]),r._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/7049147751866564621",target:"_blank",rel:"noopener noreferrer"}},[r._v("前端构建新世代，Esbuild 原来还能这么玩！"),a("OutboundLink")],1)]),r._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/TKcfBTMJgtBrz4doEwyytg",target:"_blank",rel:"noopener noreferrer"}},[r._v("快速上手 Esbuild"),a("OutboundLink")],1)]),r._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/7MR1raMmafEELiC9qTSaYQ",target:"_blank",rel:"noopener noreferrer"}},[r._v("深度：使用Esbuild为你的构建提速"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);