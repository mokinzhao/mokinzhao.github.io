(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{572:function(t,e,i){"use strict";i.r(e);var a=i(16),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"调度器-scheduler"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#调度器-scheduler"}},[t._v("#")]),t._v(" 调度器（Scheduler）")]),t._v(" "),i("h2",{attrs:{id:"时间切片-timeslice"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#时间切片-timeslice"}},[t._v("#")]),t._v(" 时间切片（TimeSlice）")]),t._v(" "),i("ul",[i("li",[t._v("React 在渲染（render）的时候，不会阻塞现在的线程")]),t._v(" "),i("li",[t._v("如果你的设备足够快，你会感觉渲染是同步的")]),t._v(" "),i("li",[t._v("如果你设备非常慢，你会感觉还算是灵敏的")]),t._v(" "),i("li",[t._v("虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来")]),t._v(" "),i("li",[t._v("同样书写组件的方式")])]),t._v(" "),i("p",[t._v("也就是说，这是 React 背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果呢？")]),t._v(" "),i("p",[i("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/128853/1564603412900-e2811022-5c2d-44d1-9893-a4647c394bb3.jpeg#align=left&display=inline&height=472&originHeight=472&originWidth=565&size=0&status=done&width=565",alt:""}}),i("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/128853/1564603412850-0ca87f6b-f5af-432e-b9de-e082b1b089de.jpeg#align=left&display=inline&height=472&originHeight=472&originWidth=565&size=0&status=done&width=565",alt:""}}),t._v("有图表三个图表，有一个输入框，以及上面的三种模式"),i("br"),i("strong",[t._v("这个组件非常的巨大，而且在输入框")]),t._v("每次**输入东西的时候，就会进去一直在渲染。**为了更好的看到渲染的性能，Dan 为我们做了一个表。")]),t._v(" "),i("p",[t._v("我们先看看，同步模式："),i("br"),i("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/128853/1564603413125-b8d05f9e-e9c6-4c64-ab7d-c509678fd461.jpeg#align=left&display=inline&height=405&originHeight=405&originWidth=566&size=0&status=done&width=566",alt:""}}),i("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/128853/1564603412868-029ea058-8277-4990-87a5-8576697084ee.jpeg#align=left&display=inline&height=405&originHeight=405&originWidth=566&size=0&status=done&width=566",alt:""}}),i("br"),t._v("同步模式下，我们都知道，我们没输入一个字符，React 就开始渲染，当 React 渲染一颗巨大的树的时候，是非常卡的，所以才会有 shouldUpdate 的出现，在这里 Dan 也展示了，这种卡！")]),t._v(" "),i("p",[t._v("我们再来看看第二种（Debounced 模式）："),i("br"),i("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/128853/1564603413109-a25c5666-3671-452a-b3b5-30af1c531d61.jpeg#align=left&display=inline&height=402&originHeight=402&originWidth=532&size=0&status=done&width=532",alt:""}}),i("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/128853/1564603412827-c64b8982-803b-4a17-8d3c-7d43f7efeafa.jpeg#align=left&display=inline&height=402&originHeight=402&originWidth=532&size=0&status=done&width=532",alt:""}}),i("br"),t._v("Debounced 模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变化。"),i("br"),t._v("这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。")]),t._v(" "),i("p",[t._v("切换到异步模式："),i("br"),i("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/128853/1564603413159-53ff5ff7-4931-4454-8b73-06127d6db6bc.jpeg#align=left&display=inline&height=426&originHeight=426&originWidth=578&size=0&status=done&width=578",alt:""}}),i("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2019/jpeg/128853/1564603412901-c9f08337-d931-495c-91f3-e5a613126c47.jpeg#align=left&display=inline&height=426&originHeight=426&originWidth=578&size=0&status=done&width=578",alt:""}}),i("br"),t._v("异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色的。")]),t._v(" "),i("p",[t._v("时间分片正是基于可随时打断、重启的 Fiber 架构,可打断当前任务,优先处理紧急且重要的任务,保证页面的流畅运行.")]),t._v(" "),i("h2",{attrs:{id:"requestidlecallback"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#requestidlecallback"}},[t._v("#")]),t._v(" requestIdleCallback")]),t._v(" "),i("h2",{attrs:{id:"问答环节"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#问答环节"}},[t._v("#")]),t._v(" 问答环节")]),t._v(" "),i("div",{staticClass:"custom-block warning"},[i("p",{staticClass:"custom-block-title"},[t._v("问")]),t._v(" "),i("p",[t._v("requestIdleCallback 和 requestAnimationFrame 的区别？")])]),t._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"custom-block-title"},[t._v("答")]),t._v(" "),i("p",[t._v("requestAnimationFrame 的回调会在每一帧确认执行, 属于高优先级任务. 而 requestIdleCallback 的回调不一定, 属于低优先级任务.\n我们看到的页面是浏览器一帧一帧绘制出来的, 通常 FPS 在 60 的时候是比较流畅的, 而 FPS 比较低的时候就会感觉到卡顿.")])]),t._v(" "),i("h2",{attrs:{id:"推荐阅读"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#推荐阅读"}},[t._v("#")]),t._v(" 推荐阅读")]),t._v(" "),i("p",[i("a",{attrs:{href:"https://juejin.cn/post/7087933643821154312",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解 scheduler 原理"),i("OutboundLink")],1)]),t._v(" "),i("p",[i("a",{attrs:{href:"https://juejin.cn/post/7021506472232583199",target:"_blank",rel:"noopener noreferrer"}},[t._v("实现 React requestIdleCallback 调度能力"),i("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);